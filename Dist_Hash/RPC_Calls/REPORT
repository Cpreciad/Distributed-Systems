
- Not implemented: client making multiple requests after a failed request
	
	Client Perspective when making requests:
	- Within the test scripts, the request calls were made to look as close to a 
		normal method call. This was achieved by creatign a class within 
		HashTableClient.py, giving a created object the four main methods to call
	- Client will be referring to how the client
		application constructs the requests to send to the server

JSON Messages:
	
	The following examples are the actual binary encoded json messages that a client
	and server can expect to accept and send	

	Input Request:
	
	- an example of one input request used in TestBasics.py
		is shown below. as seen, the json value is more complex 
		than a standard dictionary, as it contains lists and multiple keys
		b'134 {"method": "insert", "key": "Carlo", "value": 
			{"Name": "Carlo Preciado", "Age": "21", 
			"Hobbies": ["Soccer", "Basketball", "Surfing"]}}'

	- response indicating that the item was successfully inserted:
		b'78 {"status": "OK", "message": "Value Successfully Inserted",
		 	"method": "insert"}'
	
	- response indicating an unsuccessful item entry:
		b'70 {"status": "ERROR", 
		"error": "TypeError(\\"unhashable type: \'list\'\\")"}'
		
	Lookup Request:
	
	- Lookup request with a given key:
		b'30 {"method": "lookup", "key": 1}'

	- Successful lookup of an item that existed within the hash table:
		b'84 {"status": "OK", "message": "Item Retrieved", 
		"value": {"2": 3}, "method": "lookup"}'	 

	- Unsuccessful loopup of an item that does not exist in hash table:
		b'55 {"status": "ERROR", "error": "KeyError(\'another_key\')"}'

	Remove Request:
	
	- Remove request sent to the server:
		b'42 {"method": "remove", "key": "another_key"}'	

	- Remove response indicating success:
		b'96 {"status": "OK", "message": "Item Deleted", 
			"value": {"an_key": "an_value"}, "method": "remove"}' 
	
	- Remove response indicating the key did not exist
		b'55 {"status": "ERROR", "error": "KeyError(\'another_key\')"}'

	Scan Request:
	
	- Scan Request made to the server:
		b'34 {"method": "scan", "regex": "C.*"}'
	
	- Scan Response indicating success, returning values of all 
	keys and values that matches the respnse:
		b'286 {"status": "OK", "message": "Scanned Items Returned", 
		"matches": [["Carlo", {"Name":"Carlo Preciado", "Age": "21", 
		"Hobbies": ["Soccer", "Basketball", "Surfing"]}], 
		["Carlito", {"Name": "Carlo Preciado", "Age": "21", 
		"Hobbies": ["Soccer", "Basketball", "Surfing"]}]], 
		"method": "scan"}'

	- Scan response indicating success, but with no matches from the given regex:
		b'86 {"status": "OK", "message": "Scanned Items Returned",
		 "matches": [], "method": "scan"}'
	
	- Scan response indicating a failure due to an invalid regular expression:
		b'81 {"status": "ERROR", 
		"error": "error(\'unterminated character set at position 0\')"}'


	Performance data:

	- performance data was generated by creating 1001 md5 checksum hash values
		and performing each operation on the 1001 input key-value pairs

	- below are the output results from running  TestPerf.py between 
		student11 and student10:

Insert Operation:
Total Time:       0.19155628 seconds
Total Operations: 1001
Throughput:       5226 operations/second
Latency :         191365 nanoseconds/operation

Lookup Operation:
Total Time:       0.191604528 seconds
Total Operations: 1001 
Throughput:       5224 operations/second
Latency :         191413 nanoseconds/operation

Scan Operation:
Total Time:       0.537059287 seconds
Total Operations: 1001 
Throughput:       1864 operations/second
Latency :         536523 nanoseconds/operation

Remove Operation:
Total Time:       0.193741743 seconds
Total Operations: 1001 
Throughput:       5167 operations/second
Latency :         193548 nanoseconds/operation 

	A notable observation is the speed of a scan compared to the speed of the other 
	operations. the time increase of a scan makes reasonable sense, as for in my 
	implementation of scan, a regular expression must check every key in the 
	data set, resulting in an O(n) operation time.
	All other operations take about the same amount of time to complete, which 
	matches the notion that lookup, insert, and remove operations are all O(1) 
	time. 

Comparison to Homework 1 Data:

 		
	Because of the constant time complexity of 
	the three operations, we can concludethat a majority of the time 
	for each operation can be attributed to the time 
	it takes to make a request and recieve a response.
	In homework 1, it was observed that to make 100 TCP connections, it took about 
	1 second. Even though making a TCP connection is considerably slow, The client 
	server model optimized this by only having the connection be created one time, 
	allowing the client to send multiple requests per connection. 

	This indicates that a majority of the time spent to complete each operation was
	split among the many steps involved with processing a request, such as loading 
	a JSON file, Calling a function, and operating on a Python Dictionary. 

	The three operations standalone are very quick operations. But combining the 
	operations with the time it takes to send and recieve the data, it is 
	reasonable to see an increase in Latency and an overall decrease in 
	Throughput. 
